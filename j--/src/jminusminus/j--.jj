// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

/**
 * This is the input file to JavaCC for generating a scanner and
 * a parser for j--. From the specification in this file, JavaCC,
 * among other files, generates a JavaCCParser.java file under
 * $j/j--/src/jminusminus. This file is the parser. The code
 * between  PARSER_BEGIN(JavaCCParser) and PARSER_END(JavaCCParser)
 * is copied verbatim to this file. JavaCC also generates a
 * JavaCCParserTokenManager.java file which is the scanner.
 */

PARSER_BEGIN(JavaCCParser)

package jminusminus;

import java.util.ArrayList;

/**
 * Parser generated by JavaCC. It parses a j-- compilation unit 
 * (program file), taking tokens from the scanner (also generated by 
 * JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;

    /** Name of the file that is parsed. */
    private String fileName;

    /**
     * Pull out the ambiguous part of a name and return it. 
     * 
     * @param name with an ambiguos part (possibly).
     *
     * @return ambiguous part or null.
     */

    private AmbiguousName ambiguousPart(TypeName name) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf('.');
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName(name.line(),
                                qualifiedName.substring(0, lastDotIndex));
    }

    /**
     * Report a syntax error.
     * 
     * @param message message identifying the error.
     * @param args    related values.
     */

    private void reportParserError(String message, Object... args) {
        errorHasOccurred = true;
        System.err.printf("%s:%d: ", fileName, token.beginLine);
        System.err.printf(message, args);
        System.err.println();
    }

    /**
     * Recover from the parser error that occurred by skipping to
     * any of the specified tokens.
     *
     * Current error recovery mechanism is rather simple-minded and is
     * based on skipping all the tokens until a SEMI or an EOF is
     * encountered. This scheme can be enhanced by passing in the
     * FOLLOW-SET of the non-terminal at hand.
     *
     * @param skipTo array of tokens that we could skip to.
     * @param e      exception that is raised by JavaCC in the event 
     *               of a parser error.
     */

    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                expected.append("\n");
                expected.append("    ");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought",
                              getToken(1), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought",
                              getToken(1), expected);
        }

        // Recover
        boolean loop = true;
        do {
            token = getNextToken(); 
            for (int i = 0; i < skipTo.length; i++) {
                if (token.kind == skipTo[i]) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }

    /**
     * Sets the name of the file that is being parsed.
     *
     * @param fileName name of the file.
     */

    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     *
     * @return true or false.
     */

    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }
}

PARSER_END(JavaCCParser)

/////////////////////////////////////////////////////////
//         The j-- lexical grammar starts here         //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"}

// Single line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Single multiline comment -- ignored
SKIP: {<MULTI_LINE_COMMENT: "/*"> : ML_COMMENT_STATE }
<ML_COMMENT_STATE> SKIP : { "*/" : DEFAULT | < ~[] > }

// Reserved words
TOKEN: {
  <ABSTRACT: "abstract">
| <BOOLEAN: "boolean">
| <BREAK: "break">
| <BYTE: "byte">
| <CASE: "case">
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
| <CONST: "const">
| <CONTINUE: "continue">
| <DEFAULT_KW: "default">
| <DO: "do">
| <DOUBLE: "double">
| <ELSE: "else">
| <EXTENDS: "extends">
| <FINAL: "final">
| <FINALLY: "finally">
| <FLOAT: "float">
| <FOR: "for">
| <FALSE: "false">
| <GOTO: "goto">
| <IF: "if">
| <IMPLEMENTS: "implements">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
| <INTERFACE: "interface">
| <LONG: "long">
| <NATIVE: "native">
| <NEW: "new">
| <NULL: "null">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <SHORT: "short">
| <STATIC: "static">
| <STRICTFP: "strictfp">
| <SUPER: "super">
| <SWITCH: "switch">
| <SYNCHRONIZED: "synchronized">
| <THIS: "this">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRUE: "true">
| <TRY: "try">
| <VOID: "void">
| <VOLATILE: "volatile">
| <WHILE: "while">
}

// Operators (these could be combined with the reserved words)
TOKEN: {
<TERNARY: "?">
| <ASSIGN: "=">
| <EQ: "==">
| <LNOT: "!">
| <TILDE: "~">
| <NEQ: "!=">
| <DIV: "/">
| <DIV_ASSIGN: "/=">
| <PLUS: "+">
| <PLUS_ASSIGN: "+=">
| <INC: "++">
| <MINUS: "-">
| <MINUS_ASSIGN: "-=">
| <DEC: "--">
| <STAR: "*">
| <STAR_ASSIGN: "*=">
| <MOD: "%">
| <MOD_ASSIGN: "%=">
| <SHIFTR: ">>">
| <SHIFTR_ASSIGN: ">>=">
| <USHIFTR: ">>>">
| <USHIFTR_ASSIGN: ">>>=">
| <GE: ">=">
| <GT: ">">
| <SHIFTL: "<<">
| <SHIFTL_ASSIGN: "<<=">
| <LE: "<=">
| <LT: "<">
| <XOR: "^">
| <XOR_ASSIGN: "^=">
| <BIT_OR: "|">
| <BIT_OR_ASSIGN: "|=">
| <LOR: "||">
| <BIT_AND: "&">
| <BIT_AND_ASSIGN: "&=">
| <LAND: "&&">
}

// Separators (these could be combined with the reserved words)
TOKEN: {
  <LPAREN: "(">
| <RPAREN: ")">
| <LCURLY: "{">
| <RCURLY: "}">
| <LBRACK: "[">
| <RBRACK: "]">
| <SEMI: ";">
| <COLON: ":">
| <COMMA: ",">
| <DOT: ".">
}

// Identifiers
TOKEN: {
  <IDENTIFIER: (<LETTER>|"_"|"$") (<LETTER>|<DIGIT>|"_"|"$")* >
| <#LETTER: ["a"-"z","A"-"Z"] >
| <#DIGIT: ["0"-"9"] >
| <#NON_ZERO_DIGIT: ["1"-"9"] >
}

// Literals
TOKEN: {
  <INT_LITERAL: ("0" | <NON_ZERO_DIGIT> (<DIGIT>)*) >
| <CHAR_LITERAL: "'" (<ESC> | ~["'","\\","\n","\r"]) "'" >
| <STRING_LITERAL: "\"" (<ESC> | ~["\"","\\","\n","\r"])* "\"" >
| <DOUBLE_LITERAL: ((<DIGIT>)* "." (<DIGIT>)+ | (<DIGIT>)+ (".")? (<DIGIT>)*) (["e", "E"] (["+", "-"])? (<DIGIT>)+)? (["f", "F", "d", "D"])? >
| <#ESC: "\\" ["n","t","b","r","f","\\","'","\""] >
}

// For anything else, we return an ERROR token. Without this 
// definition the TokenManager will throw an Error when a lexical 
// error occurs, making it impossible to recover from it. So we 
// define this ERROR token.
TOKEN: { <ERROR: ~[]> }

/////////////////////////////////////////////////////////
//       The j-- syntactic grammar starts here         //
/////////////////////////////////////////////////////////

/**
 * Parses a compilation unit (a program file) and construct an AST 
 * for it. After constructing the Parser, this is its entry point.
 * 
 * <pre>
 *   compilationUnit ::= [PACKAGE qualifiedIdentifier SEMI]
 *                       {IMPORT  qualifiedIdentifier SEMI}
 *                       {typeDeclaration}
 *                       EOF
 * </pre>
 * 
 * @return an AST for a compilationUnit.
 */

public JCompilationUnit compilationUnit(): {
    int line = 0;
    TypeName packageName = null; // Default
    TypeName anImport = null;
    ArrayList<TypeName> imports = new ArrayList<TypeName>();
    JAST aTypeDeclaration = null;
    ArrayList<JAST> typeDeclarations = new ArrayList<JAST>();
}
{
    try {
        [
            <PACKAGE> { line = token.beginLine; }
            packageName = qualifiedIdentifier()
            <SEMI>
        ]
        (
            <IMPORT> { line = line == 0 ? token.beginLine : line; }
            anImport = qualifiedIdentifier()
            { imports.add(anImport); }
            <SEMI>
        )*
        (
            aTypeDeclaration = typeDeclaration()
            {
                line = line == 0 ? aTypeDeclaration.line() : line;
                typeDeclarations.add(aTypeDeclaration);
            }
        )*
        <EOF> { line = line == 0 ? token.beginLine : line; }
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    {
        return new JCompilationUnit(fileName, line, packageName,
                                    imports, typeDeclarations);
    }
}

/**
 * Parse a qualified identifier.
 * 
 * <pre>
 *   qualifiedIdentifier ::= IDENTIFIER {DOT IDENTIFIER}
 * </pre>
 * 
 * @return an instance of TypeName.
 */

private TypeName qualifiedIdentifier(): {
    int line = 0;
    String qualifiedIdentifier = "";
}
{
    try {
        <IDENTIFIER>
        {
            line = token.beginLine;
            qualifiedIdentifier = token.image;
        }
        (
            LOOKAHEAD(<DOT> <IDENTIFIER>) // Suppress JavaCC warning
            <DOT> <IDENTIFIER>
            { qualifiedIdentifier += "." + token.image; }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new TypeName(line, qualifiedIdentifier); }
}

/**
 * Parse a type declaration.
 * 
 * <pre>
 *   typeDeclaration ::= modifiers (classDeclaration | interfaceDeclaration)
 * </pre>
 * 
 * @return an AST for a typeDeclaration.
 */

private JAST typeDeclaration(): {
    ArrayList<String> mods = null;
    JAST declaration = null;
}
{
    try {
        mods = modifiers()
        (
            declaration = classDeclaration(mods)
            |
            declaration = interfaceDeclaration(mods)
        )
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return declaration; }
}

/**
 * Parse modifiers. Check for duplicates, and conflicts among access modifiers
 * (public, protected, and private). Otherwise, no checks.
 *
 * <pre>
 *   modifiers ::= {PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL | VOLATILE | TRANSIENT}
 * </pre>
 * 
 * 
 * @return a list of modifiers.
 */

private ArrayList<String> modifiers(): {
    ArrayList<String> mods      = new ArrayList<>();
    boolean scannedPUBLIC       = false;
    boolean scannedPROTECTED    = false;
    boolean scannedPRIVATE      = false;
    boolean scannedSTATIC       = false;
    boolean scannedABSTRACT     = false;
    boolean scannedFINAL        = false;
    boolean scannedVOLATILE     = false;
    boolean scannedTRANSIENT    = false;
    boolean scannedSYNCHRONIZED = false;
    boolean scannedNATIVE       = false;
    boolean scannedSTRICTFP     = false;
}
{
    try {
        (
            <PUBLIC>
            {
                mods.add("public");
                if (scannedPUBLIC) {
                    reportParserError("Repeated modifier: public");
                }
                if (scannedPROTECTED || scannedPRIVATE) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPUBLIC = true;
            } |
            <PROTECTED>
            {
                mods.add("protected");
                if (scannedPROTECTED) {
                    reportParserError("Repeated modifier: protected");
                }
                if (scannedPUBLIC || scannedPRIVATE) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPROTECTED = true;
            } |
            <PRIVATE>
            {
                mods.add("private");
                if (scannedPRIVATE) {
                    reportParserError("Repeated modifier: private");
                }
                if (scannedPUBLIC || scannedPROTECTED) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPRIVATE = true;
            } |
            <STATIC>
            {
                mods.add("static");
                if (scannedSTATIC) {
                    reportParserError("Repeated modifier: static");
                }
                scannedSTATIC = true;
            } |
            <ABSTRACT>
            {
                mods.add("abstract");
                if (scannedABSTRACT) {
                    reportParserError("Repeated modifier: abstract");
                }
                scannedABSTRACT = true;
            } |
            <FINAL>
            {
                mods.add("final");
                if (scannedFINAL) {
                    reportParserError("Repeated modifier: final");
                }
                scannedFINAL = true;
            } |
            <VOLATILE>
            {
                mods.add("volatile");
                if (scannedVOLATILE) {
                    reportParserError("Repeated modifier: volatile");
                }
                scannedVOLATILE = true;
            } |
            <SYNCHRONIZED>
            {
                mods.add("synchronized");
                if (scannedSYNCHRONIZED) {
                    reportParserError("Repeated modifier: synchronized");
                }
                scannedSYNCHRONIZED = true;
            } |
            <NATIVE>
            {
                mods.add("native");
                if (scannedNATIVE) {
                    reportParserError("Repeated modifier: native");
                }
                scannedNATIVE = true;
            } |
            <STRICTFP>
            {
                mods.add("strictfp");
                if (scannedSTRICTFP) {
                    reportParserError("Repeated modifier: strictfp");
                }
                scannedSTRICTFP = true;
            } |
            <TRANSIENT>
            {
                mods.add("transient");
                if (scannedTRANSIENT) {
                    reportParserError("Repeated modifier: transient");
                }
                scannedTRANSIENT = true;
            }
        )*
    }
    catch (ParseException e) { 
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return mods; }
}


/**
 * Parse an interface declaration.
 *
 * <pre>
 *   interfaceDeclaration ::= INTERFACE IDENTIFIER
 *                        [EXTENDS qualifiedIdentifier {, qualifiedIdentifier}]
 *                        interfaceBody
 * </pre>
 *
 * @param mods the interface modifiers.
 *
 * @return an AST for an interfaceDeclaration.
 */

private JInterfaceDeclaration interfaceDeclaration(ArrayList<String> mods): {
    int line = 0;
    String name = "";
    TypeName anInterface = null;
    ArrayList<TypeName> extendedInterfaces = new ArrayList<>();
    ArrayList<JMember> interfaceBody = null;
}
{
    try {
        <INTERFACE> { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
        [
            <EXTENDS> anInterface = qualifiedIdentifier() { extendedInterfaces.add(anInterface); }
            (
                <COMMA> anInterface = qualifiedIdentifier() { extendedInterfaces.add(anInterface); }
            )*
        ]
        interfaceBody = interfaceBody()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    {
        return new JInterfaceDeclaration(line, mods, name, extendedInterfaces, interfaceBody);
    }
}

/**
 * Parse an interface body.
 *
 * <pre>
 *   interfaceBody ::= LCURLY {modifiers interfaceMemberDecl} RCURLY
 * </pre>
 *
 * @return list of members in the interface body.
 */

private ArrayList<JMember> interfaceBody(): {
    ArrayList<String> mods = null;
    JMember aMember        = null;
    ArrayList<JMember> members = new ArrayList<>();
}
{
    try {
        <LCURLY>
        (
            mods = modifiers()
            aMember = interfaceMemberDecl(mods) { members.add(aMember); }
        )*
        <RCURLY>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return members; }
}

/**
 * Parse a class declaration. A class which doesn't explicitly extend another
 * (super) class implicitly extends the superclass java.lang.Object.
 * 
 * <pre>
 *   classDeclaration ::= CLASS IDENTIFIER
 *                        [EXTENDS qualifiedIdentifier]
 *                        [IMPLEMENTS qualifiedIdentifier {COMMA qualifiedIdentifier}]
 *                        classBody
 * </pre>
 * 
 * 
 * @param mods the class modifiers.
 *
 * @return an AST for a classDeclaration.
 */

private JClassDeclaration classDeclaration(ArrayList<String> mods): {
    int line = 0;
    String name = "";
    Type superClass = Type.OBJECT;
    TypeName anInterface = null;
    ArrayList<TypeName> implemented = new ArrayList<>();
    ArrayList<JMember> classBody = null;
}
{
    try {
        <CLASS> { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
        [
            <EXTENDS> superClass = qualifiedIdentifier()
        ]
        [
            <IMPLEMENTS> anInterface = qualifiedIdentifier() { implemented.add(anInterface); }
            (
                <COMMA> anInterface = qualifiedIdentifier() { implemented.add(anInterface); }
            )*
        ]
        classBody = classBody()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    {
        return new JClassDeclaration(line, mods, name, superClass, implemented, classBody);
    }
}

/**
 * Parse a class body.
 * 
 * <pre>
 *   classBody ::= LCURLY
 *                   {STATIC block | block | modifiers memberDecl}
 *                 RCURLY
 * </pre>
 * 
 * @return list of members in the class body.
 */

private ArrayList<JMember> classBody(): {
    ArrayList<String> mods = null;
    JMember aMember        = null;
    JBlock aBlock        = null;
    ArrayList<JMember> members = new ArrayList<>();
}
{
    try {
        <LCURLY>
        (
            LOOKAHEAD(<STATIC> <LCURLY>)
            <STATIC>
            aBlock = block() { members.add(new JInitializationBlock(aBlock, true)); }
            | (
                aBlock = block() { members.add(new JInitializationBlock(aBlock, false)); }
            ) |
            (
                mods = modifiers()
                aMember = memberDecl(mods) { members.add(aMember); }
            )
        )*
        <RCURLY>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return members; }
}


/**
 * Parse an interface member declaration.
 *
 * <pre>
 *   interfaceMemberDecl ::= (VOID | type) IDENTIFIER formalParameters [THROWS qualifiedIdentifier {COMMA qualifiedIdentifier}] SEMI // method
 *                          | type variableDeclarators SEMI // field
 *                          | classDeclaration
 *                          | interfaceDeclaration
 * </pre>
 *
 * @param mods the class member modifiers.
 *
 * @return an AST for a memberDecl.
 */

private JMember interfaceMemberDecl(ArrayList<String> mods): {
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
    TypeName thrown;
    ArrayList<TypeName> thrownList = new ArrayList<>();
}
{
    try {
        LOOKAHEAD((<VOID> | type()) <IDENTIFIER> <LPAREN>)
        (
            (
                <VOID> { type = Type.VOID; } |
                type = type()
            )
            { line = token.beginLine; }
            <IDENTIFIER> { name = token.image; }
            params = formalParameters()
            [
                <THROWS> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                (
                    <COMMA> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                )*
            ]
            <SEMI>
            {
                memberDecl = new JMethodDeclaration(line, mods, name, type, params, thrownList, null);
            }
        ) |
        (
            type = type() { line = token.beginLine; }
            variableDeclarators = variableDeclarators(type)
            <SEMI>
            {
                memberDecl = new JFieldDeclaration(line, mods, variableDeclarators);
            }
        ) |
        (
            memberDecl = classDeclaration(mods)
        ) |
        (
            memberDecl = interfaceDeclaration(mods)
        )
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return memberDecl; }
}

/**
 * Parse a member declaration.
 * 
 * <pre>
 *   memberDecl ::= IDENTIFIER            // constructor
 *                    formalParameters
 *                    [THROWS qualifiedIdentifier {COMMA qualifiedIdentifier}]
 *                    block
 *                | (VOID | type) IDENTIFIER  // method
 *                    formalParameters
 *                    [THROWS qualifiedIdentifier {COMMA qualifiedIdentifier}]
 *                    (block | SEMI)
 *                | type variableDeclarators SEMI
 *                | classDeclaration
 *                | interfaceDeclaration
 * </pre>
 * 
 * @param mods the class member modifiers.
 *
 * @return an AST for a memberDecl.
 */
    
private JMember memberDecl(ArrayList<String> mods): {
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    JBlock body = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
    TypeName thrown = null;
    ArrayList<TypeName> thrownList = new ArrayList<>();
}
{
    try {
        LOOKAHEAD(<IDENTIFIER> <LPAREN>)
        (
            <IDENTIFIER>
            {
                line = token.beginLine;
                name = token.image;
            }
            params = formalParameters()
            [
                <THROWS> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                (
                    <COMMA> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                )*
            ]
            body = block()
            {
                memberDecl = new JConstructorDeclaration(line, mods, name, params, thrownList, body);
            }
        ) |
        LOOKAHEAD((<VOID> | type()) <IDENTIFIER> <LPAREN>)
        (
            (
                <VOID> { type = Type.VOID; } |
                type = type()
            )
            { line = token.beginLine; }
            <IDENTIFIER> { name = token.image; }
            params = formalParameters()
            [
                <THROWS> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                (
                    <COMMA> thrown = qualifiedIdentifier() { thrownList.add(thrown); }
                )*
            ]
            (
                body = block() |
                <SEMI>
            )
            {
                memberDecl = new JMethodDeclaration(line, mods, name, type, params, thrownList, body);
            }
        ) |
        (
            type = type() { line = token.beginLine; }
            variableDeclarators = variableDeclarators(type)
            <SEMI>
            {
                memberDecl = new JFieldDeclaration(line, mods, variableDeclarators);
            }
        ) | (
            memberDecl = classDeclaration(mods)
        ) | (
            memberDecl = interfaceDeclaration(mods)
        )
    }
    catch (ParseException e) { 
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return memberDecl; }
}

/**
 * Parse a block.
 * 
 * <pre>
 *   block ::= LCURLY {blockStatement} RCURLY 
 * </pre>
 * 
 * @return an AST for a block.
 */

private JBlock block(): {
    int line = 0;
    JStatement aStatement = null;
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        (
            aStatement = blockStatement()
            { statements.add(aStatement); }
        )*
        <RCURLY>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JBlock(line, statements); }
}

/**
 * Parse a block statement.
 * 
 * <pre>
 *   blockStatement ::= localVariableDeclarationStatement
 *                    | statement
 * </pre>
 * 
 * @return an AST for a blockStatement.
 */

private JStatement blockStatement(): {
    JStatement statement = null;
}
{
    try {
        LOOKAHEAD(type() <IDENTIFIER>)
        statement = localVariableDeclarationStatement() |
        statement = statement()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statement; }
}

/**
 * Parse a statement.
 * 
 * <pre>
 *   statement ::= block
 *               | IF parExpression statement [ELSE statement]
 *               | FOR LPAREN [forInit] SEMI [expression] SEMI [forUpdate] RPAREN statement
 *               | FOR LPAREN formalParameter COLON qualifiedIdentifier RPAREN statement
 *               | WHILE parExpression statement
 *               | DO statement WHILE LPAREN expression RPAREN SEMI
 *               | TRY block {CATCH LPAREN formalParameter RPAREN block} [FINALLY block]
 *               | RETURN [expression] SEMI
 *               | BREAK SEMI
 *               | CONTINUE SEMI
 *               | THROW expression SEMI
 *               | SEMI
 *               | statementExpression SEMI
 * </pre>
 * 
 * @return an AST for a statement.
 */

private JStatement statement(): {
    int line                            = 0;
    int subline                         = 0;
    JStatement statement                = null;
    JExpression test                    = null;
    JStatement consequent               = null;
    JStatement alternate                = null;
    JStatement body                     = null;
    JExpression expr                    = null;
    JForInit aForInit                   = null;
    JStatement aForUpdate               = null;
    ArrayList<JStatement> forUpdates    = new ArrayList<>();
    JFormalParameter formal             = null;
    ArrayList<JCatchClause> catches     = new ArrayList<>();
    boolean hasCatch                    = false;
    JBlock try_body                     = null;
    JBlock catch_body                   = null;
    JBlock finally_body                 = null;
}
{
    try {
        statement = block()

        |

        <BREAK> { line = token.beginLine; }
        <SEMI> { statement = new JEmptyStatement(line); } // TODO: HANDLE BREAK

        |

        <CONTINUE> { line = token.beginLine; }
        <SEMI> { statement = new JEmptyStatement(line); } // TODO: HANDLE CONTINUE

        |

        <THROW> { line = token.beginLine; }
        expr = expression()
        <SEMI> { statement = new JThrowStatement(line, expr); }

        |
        
        <IF> { line = token.beginLine; }
        test = parExpression()
        consequent = statement()

        // Even without the lookahead below, which is added to 
        // suppress JavaCC warnings, dangling if-else problem is 
        // resolved by binding the alternate to the closest 
        // consequent.
        [
            LOOKAHEAD(<ELSE>)
            <ELSE> alternate = statement()
        ]
        { statement = new JIfStatement(line, test, consequent, alternate); }

        |

        LOOKAHEAD(<FOR><LPAREN> formalParameter() <COLON>)
        <FOR> { line = token.beginLine; }
        <LPAREN>
        formal = formalParameter()
        <COLON>
        expr = expression()
        <RPAREN>
        body = statement()
        { statement = new JForeachStatement(line, formal, expr, body); }

        |

        <FOR> { line = token.beginLine; }
        <LPAREN>
        [ aForInit = forInit() ]
        <SEMI>
        [ expr = expression() ]
        <SEMI>
        [
            aForUpdate = statementExpression() { forUpdates.add(aForUpdate); }
            (
                <COMMA> aForUpdate = statementExpression() { forUpdates.add(aForUpdate); }
            )*
        ]
        <RPAREN>
        body = statement()
        { statement = new JForStatement(line, aForInit, expr, forUpdates, body); }

        |

        <WHILE> { line = token.beginLine; }
        test = parExpression()
        body = statement()
        { statement = new JWhileStatement(line, test, body); }

        |

        <DO> { line = token.beginLine; }
        body = statement()
        <WHILE>
        test = parExpression()
        <SEMI>
        { statement = new JDoWhileStatement(line, test, body); }

        |

        <TRY> { line = token.beginLine; }
        try_body = block()
        (
            <CATCH> { subline = token.beginLine; }
            <LPAREN> formal = formalParameter() <RPAREN>
            catch_body = block()
            { catches.add(new JCatchClause(subline, formal, catch_body)); hasCatch = true; }
        )*
        [
            <FINALLY>
            finally_body = block() { hasCatch = true; }
        ]
        {
            if (!hasCatch) reportParserError("try block needs a catch clause or a finally block");
            statement = new JTryCatchStatement(line, try_body, catches, finally_body);
        }

        |

        <RETURN> { line = token.beginLine; }
        [
            expr = expression()
        ]
        <SEMI>
        { statement = new JReturnStatement(line, expr); }

        |

        <SEMI>
        { line = token.beginLine; statement = new JEmptyStatement( line ); }

        |

        // Must be a statementExpression
        statement = statementExpression()
        <SEMI>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statement; }
}


private JForInit forInit(): {
    JStatement statement = null;
    JVariableDeclarator declarator = null;
    ArrayList<JVariableDeclarator> variableDeclarators = new ArrayList<>();
    ArrayList<JStatement> statements = new ArrayList<>();
    boolean isFinal = false;
    Type typ = null;
}
{
    try {
        LOOKAHEAD([<FINAL>] type() variableDeclarator(typ))
        (
            [<FINAL> {isFinal = true;}] // TODO: IGNORED FOR NOW
            typ = type()
            declarator = variableDeclarator(typ) { variableDeclarators.add(declarator); }
            (
                <COMMA> declarator = variableDeclarator(typ) { variableDeclarators.add(declarator); }
            )*
            { return new JForInit(variableDeclarators, null); }
        ) | (
            statement = statementExpression() { statements.add(statement); }
            (
                <COMMA> statement = statementExpression() { statements.add(statement); }
            )*
            { return new JForInit(null, statements); }
        )
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
}

/**
 * Parse formal parameters.
 * 
 * <pre>
 *   formalParameters ::= LPAREN 
 *                          [formalParameter 
 *                            {COMMA  formalParameter}]
 *                        RPAREN
 * </pre>
 * 
 * @return a list of formal parameters.
 */

private ArrayList<JFormalParameter> formalParameters(): {
    ArrayList<JFormalParameter> parameters = new ArrayList<JFormalParameter>();
    JFormalParameter aParameter = null;
}
{
    try {
        <LPAREN>
        [
            aParameter = formalParameter()
            { parameters.add(aParameter); }
            (
                <COMMA> aParameter = formalParameter()
                { parameters.add(aParameter); }
            )*
        ]
        <RPAREN>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return parameters; }
}

/**
 * Parse a formal parameter.
 * 
 * <pre>
 *   formalParameter ::= type IDENTIFIER
 * </pre>
 * 
 * @return an AST for a formalParameter.
 */

private JFormalParameter formalParameter(): {
    int line    = 0;
    Type type   = null;
    String name = "";
}
{
    try {
        type = type() { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JFormalParameter(line, name, type); }
}

/**
 * Parse a parenthesized expression.
 * 
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 * 
 * @return an AST for a parExpression.
 */

private JExpression parExpression(): {
    JExpression expr = null;
}
{
    try {
        <LPAREN> expr = expression() <RPAREN>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse a local variable declaration statement.
 * 
 * <pre>
 *   localVariableDeclarationStatement ::= type
 *                                           variableDeclarators
 *                                             SEMI
 * </pre>
 * 
 * @return an AST for a variableDeclaration.
 */

private JVariableDeclaration localVariableDeclarationStatement(): {
    int line = 0;
    Type type = null;
    ArrayList<JVariableDeclarator> vdecls = null;
    ArrayList<String> mods = new ArrayList<String>();
}
{
    try {
        type = type() { line = token.beginLine; }
        vdecls = variableDeclarators(type)
        <SEMI>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JVariableDeclaration(line, mods, vdecls); }
}

/**
 * Parse variable declarators.
 * 
 * <pre>
 *   variableDeclarators ::= variableDeclarator
 *                             {COMMA variableDeclarator}
 * </pre>
 * 
 * @param type type of the variables.
 *
 * @return a list of variable declarators.
 */

private ArrayList<JVariableDeclarator> variableDeclarators(Type type): {
    JVariableDeclarator aVariableDeclarator = null;
    ArrayList<JVariableDeclarator> variableDeclarators =
        new ArrayList<JVariableDeclarator>();
}
{
    try {
        aVariableDeclarator = variableDeclarator(type)
        { variableDeclarators.add(aVariableDeclarator); }
        (
            <COMMA> aVariableDeclarator = variableDeclarator(type)
            { variableDeclarators.add(aVariableDeclarator); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return variableDeclarators; }
}

/**
 * Parse a variable declarator.
 * 
 * <pre>
 *   variableDeclarator ::= IDENTIFIER
 *                          [ASSIGN variableInitializer]
 * </pre>
 * 
 * @param type type of the variable.
 *
 * @return an AST for a variableDeclarator.
 */

private JVariableDeclarator variableDeclarator(Type type): {
    int line = 0;
    JExpression initial = null;
    String name = "";
}
{
    try {
        <IDENTIFIER> { line = token.beginLine; name = token.image; }
        [
            <ASSIGN> initial = variableInitializer(type)
        ]
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JVariableDeclarator(line, name, type, initial); }
}

/**
 * Parse a variable initializer.
 * 
 * <pre>
 *   variableInitializer ::= arrayInitializer
 *                         | expression
 * </pre>
 * 
 * @param type type of the variable.
 *
 * @return an AST for a variableInitializer.
 */

private JExpression variableInitializer(Type expected): {
    JExpression initializer = null;
}
{
    try {
        initializer = arrayInitializer(expected) |
        initializer = expression()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return initializer; }
}

/**
 * Parse an array initializer.
 * 
 * <pre>
 *   arrayInitializer ::= LCURLY
 *                          [variableInitializer
 *                            {COMMA variableInitializer} [COMMA]]
 *                        RCURLY 
 * </pre>
 * 
 * @param type type of the array.
 *
 * @return an AST for an arrayInitializer.
 */

private JArrayInitializer arrayInitializer(Type expected): {
    int line = 0;
    ArrayList<JExpression> initials = new ArrayList<JExpression>();
    JExpression anInitializer = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        [
            anInitializer = variableInitializer(expected.componentType())
            { initials.add(anInitializer); }
            (
                <COMMA>
                anInitializer = variableInitializer(expected.componentType())
                { initials.add(anInitializer); }
            )*
        ]
        <RCURLY>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JArrayInitializer(line, expected, initials); }
}

/**
 * Parse arguments.
 * 
 * <pre>
 *   arguments ::= LPAREN [expression {COMMA expression}] RPAREN
 * </pre>
 * 
 * @return a list of expressions.
 */

private ArrayList<JExpression> arguments(): {
    ArrayList<JExpression> args = new ArrayList<JExpression>();
    JExpression anExpression = null;
}
{
    try {
        <LPAREN>
        [
            anExpression = expression() { args.add(anExpression); }
            (
                <COMMA> anExpression = expression()
                { args.add(anExpression); }
            )*
        ]
        <RPAREN>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return args; }
}

/**
 * Parse a type.
 * 
 * <pre>
 *   type ::= referenceType
 *          | basicType
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type type(): {
    Type type = null;
}
{
    try {
        LOOKAHEAD(<IDENTIFIER> | basicType() <LBRACK> <RBRACK>)
        type = referenceType() |
        type = basicType()
    }
    catch (ParseException e) {
       recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return type; }
}

/**
 * Parse a basic type.
 * 
 * <pre>
 *   basicType ::= BOOLEAN | CHAR | INT | LONG | SHORT | BYTE | DOUBLE | FLOAT
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type basicType(): {
    Type type = Type.ANY;
}
{
    try {
        <BOOLEAN> { type = Type.BOOLEAN; } |
        <CHAR> { type = Type.CHAR; } |
        <INT> { type = Type.INT; } |
        <LONG> { type = Type.INT; } |
        <SHORT> { type = Type.INT; } |
        <BYTE> { type = Type.INT; } |
        <DOUBLE> { type = Type.DOUBLE; } |
        <FLOAT> { type = Type.DOUBLE; }
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return type; }
}

/**
 * Parse a reference type.
 * 
 * <pre>
 *   referenceType ::= basicType LBRACK RBRACK {LBRACK RBRACK}
 *                   | qualifiedIdentifier {LBRACK RBRACK}
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type referenceType(): {
    Type type = Type.ANY;
}
{
    try {
        type = basicType()
        <LBRACK> <RBRACK> { type = new ArrayTypeName(type); }
        (
            <LBRACK> <RBRACK>
            { type = new ArrayTypeName(type); }
        )* |
        type = qualifiedIdentifier()
        (
            <LBRACK> <RBRACK>
            { type = new ArrayTypeName(type); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return type; }
}

/**
 * Parse a statement expression.
 * 
 * <pre>
 *   statementExpression ::= expression // but must have a
 *                                      // side-effect, eg. i++
 * </pre>
 * 
 * @return an AST for a statementExpression.
 */

private JStatement statementExpression(): {
    int line = 0;
    JExpression expr = null;
}
{
    try {
        expr = expression()
        {
            line = expr.line();
            if (expr instanceof JAssignment
             || expr instanceof JPreIncrementOp
             || expr instanceof JPreDecrementOp
             || expr instanceof JPostDecrementOp
             || expr instanceof JPostIncrementOp
             || expr instanceof JMessageExpression
             || expr instanceof JSuperConstruction
             || expr instanceof JThisConstruction 
             || expr instanceof JNewOp
             || expr instanceof JNewArrayOp) {
                // So as not to save on stack
                expr.isStatementExpression = true;
            } else {
                reportParserError("Invalid statement expression; " +
                                  "it does not have a side-effect");
            }
        }
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JStatementExpression( line, expr ); }
}

/**
 * An expression.
 * 
 * <pre>
 *   expression ::= assignmentExpression
 * </pre>
 * 
 * @return an AST for an expression.
 */

private JExpression expression(): {
    JExpression expr = null;
}
{
    try {
        expr = assignmentExpression()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse an assignment expression.
 * 
 * <pre>
 *   assignmentExpression ::= 
 *       conditionalExpression                // level 13
 *           [( ASSIGN       // must be valid lhs
 *            | PLUS_ASSIGN 
 *            | MINUS_ASSIGN
 *            | STAR_ASSIGN
 *            | DIV_ASSIGN
 *            | MOD_ASSIGN
 *            | SHIFTR_ASSIGN
 *            | USHIFTR_ASSIGN
 *            | SHIFTL_ASSIGN
 *            | XOR_ASSIGN
 *            | BIT_AND_ASSIGN
 *            | BIT_OR_ASSIGN
 *            )
 *            assignmentExpression]
 * </pre>
 * 
 * @return an AST for an assignmentExpression.
 */

private JExpression assignmentExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalExpression() { line = lhs.line(); }
        [
            <ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JAssign(line, lhs, rhs); } |

            <PLUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JPlusAssign(line, lhs, rhs); } |

            <MINUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JMinusAssign(line, lhs, rhs); } |

            <STAR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JStarAssign(line, lhs, rhs); } |

            <DIV_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JDivAssign(line, lhs, rhs); } |

            <MOD_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JModAssign(line, lhs, rhs); } |

            <SHIFTR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JShiftRAssign(line, lhs, rhs); } |

            <USHIFTR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JUshiftRAssign(line, lhs, rhs); } |

            <SHIFTL_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JShiftLAssign(line, lhs, rhs); } |

            <XOR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JXorAssign(line, lhs, rhs); } |

            <BIT_AND_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JBitAndAssign(line, lhs, rhs); } |

            <BIT_OR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JBitOrAssign(line, lhs, rhs); }
        ]
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a conditional expression.
 *
 * <pre>
 *   conditionalExpression ::= conditionalOrExpression        // level 12
 *                                  [TERNARY assignmentExpression COLON conditionalExpression]
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalExpression(): {
    int line = 0;
    JExpression ret = null;
    JExpression condition = null, trueBranch = null, falseBranch = null;
}
{
    try {
        condition = conditionalOrExpression() { line = condition.line(); }
        [
            <TERNARY>
            trueBranch = assignmentExpression()
            <COLON>
            falseBranch = conditionalExpression()
            { return new JConditionalExpression(line, condition, trueBranch, falseBranch); }
        ]
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return condition; }
}

/**
 * Parse a conditional-or expression.
 *
 * <pre>
 *   conditionalOrExpression ::= conditionalAndExpression        // level 11
 *                                  {LOR conditionalAndExpression}
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalOrExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalAndExpression() { line = lhs.line(); }
        (
            <LOR>
            rhs = conditionalAndExpression()
            { lhs = new JLogicalOrOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a conditional-and expression.
 * 
 * <pre>
 *   conditionalAndExpression ::= inclusiveOrExpression        // level 10
 *                                  {LAND inclusiveOrExpression}
 * </pre>
 * 
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalAndExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = inclusiveOrExpression() { line = lhs.line(); }
        (
            <LAND>
            rhs = inclusiveOrExpression()
            { lhs = new JLogicalAndOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a inclusive-or expression.
 *
 * <pre>
 *   inclusiveOrExpression ::= exclusiveOrExpression        // level 9
 *                                  {BIT_OR exclusiveOrExpression}
 * </pre>
 *
 * @return an AST for a inclusiveOrExpression.
 */

private JExpression inclusiveOrExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = exclusiveOrExpression() { line = lhs.line(); }
        (
            <BIT_OR>
            rhs = exclusiveOrExpression()
            { lhs = new JBitOrOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a exclusive-or expression.
 *
 * <pre>
 *   exclusiveOrExpression ::= andExpression        // level 8
 *                                  {XOR andExpression}
 * </pre>
 *
 * @return an AST for a exclusiveOrExpression.
 */

private JExpression exclusiveOrExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = andExpression() { line = lhs.line(); }
        (
            <XOR>
            rhs = andExpression()
            { lhs = new JXorOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse an and expression.
 *
 * <pre>
 *   andExpression ::= equalityExpression        // level 7
 *                                  {BIT_AND equalityExpression}
 * </pre>
 *
 * @return an AST for a andExpression.
 */

private JExpression andExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = equalityExpression() { line = lhs.line(); }
        (
            <BIT_AND>
            rhs = equalityExpression()
            { lhs = new JBitAndOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse an equality expression.
 * 
 * <pre>
 *   equalityExpression ::= relationalExpression         // level 6
 *                            {EQ relationalExpression}
 * </pre>
 * 
 * @return an AST for an equalityExpression.
 */

private JExpression equalityExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = relationalExpression() { line = lhs.line(); }
        (
            <EQ>
            rhs = relationalExpression()
            { lhs = new JEqualOp(line, lhs, rhs); } |

            <NEQ>
            rhs = relationalExpression()
            { lhs = new JNotEqualOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a relational expression.
 * 
 * <pre>
 *   relationalExpression ::= shiftExpression            // level 5
 *                              [(GT | LT | GE | LE) shiftExpression
 *                              | INSTANCEOF referenceType]
 * </pre>
 * 
 * @return an AST for a relationalExpression.
 */

private JExpression relationalExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
    Type type = null;
}
{
    try {
        lhs = shiftExpression() { line = lhs.line(); }
        [
            <GT>
            rhs = shiftExpression()
            { lhs = new JGreaterThanOp(line, lhs, rhs); } |

            <LT>
            rhs = shiftExpression()
            { lhs = new JLessThanOp(line, lhs, rhs); } |

            <LE>
            rhs = shiftExpression()
            { lhs = new JLessEqualOp(line, lhs, rhs); } |

            <GE>
            rhs = shiftExpression()
            { lhs = new JGreaterEqualOp(line, lhs, rhs); } |

            <INSTANCEOF>
            type = referenceType()
            { lhs = new JInstanceOfOp(line, lhs, type); }
        ]
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse an shift expression.
 *
 * <pre>
 *   shiftExpression ::= additiveExpression         // level 4
 *                            {(SHIFTR | USHIFTR | SHIFTL) additiveExpression}
 * </pre>
 *
 * @return an AST for an shiftExpression.
 */

private JExpression shiftExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = additiveExpression() { line = lhs.line(); }
        (
            <SHIFTL>
            rhs = additiveExpression()
            { lhs = new JShiftLeftOp(line, lhs, rhs); } |

            <SHIFTR>
            rhs = additiveExpression()
            { lhs = new JShiftRightOp(line, lhs, rhs); } |

            <USHIFTR>
            rhs = additiveExpression()
            { lhs = new JShiftUOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse an additive expression.
 * 
 * <pre>
 *   additiveExpression ::= multiplicativeExpression         // level 3
 *                            {(PLUS | MINUS) multiplicativeExpression}
 * </pre>
 * 
 * @return an AST for an additiveExpression.
 */

private JExpression additiveExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = multiplicativeExpression() { line = lhs.line(); } 
        (
            <PLUS>
            rhs = multiplicativeExpression()
            { lhs = new JPlusOp(line, lhs, rhs); } |

            <MINUS>
            rhs = multiplicativeExpression()
            { lhs = new JSubtractOp(line, lhs, rhs); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse a multiplicative expression.
 * 
 * <pre>
 *   multiplicativeExpression ::= unaryExpression        // level 2
 *                                  {(STAR | DIV | MOD) unaryExpression}
 * </pre>
 * 
 * @return an AST for a multiplicativeExpression.
 */

private JExpression multiplicativeExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = unaryExpression() { line = lhs.line(); }
        (
            (
                <STAR>
                rhs = unaryExpression()
                { lhs = new JMultiplyOp(line, lhs, rhs); }
            ) |
            (
                <DIV>
                rhs = unaryExpression()
                { lhs = new JDivideOp(line, lhs, rhs); }
            ) |
            (
                <MOD>
                rhs = unaryExpression()
                { lhs = new JModOp(line, lhs, rhs); }
            )
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parse an unary expression.
 * 
 * <pre>
 *   unaryExpression ::= INC unaryExpression // level 1
 *                     | DEC unaryExpression
 *                     | PLUS unaryExpression
 *                     | MINUS unaryExpression
 *                     | simpleUnaryExpression
 * </pre>
 * 
 * @return an AST for an unaryExpression.
 */

private JExpression unaryExpression(): {
    int line = 0;
    JExpression expr = null, unaryExpr = null;
}
{
    try {
        <INC> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreIncrementOp(line, unaryExpr); } |

        <DEC> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreDecrementOp(line, unaryExpr); } |

        <MINUS> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JNegateOp(line, unaryExpr); } |

        <PLUS> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JUnaryPlusOp(line, unaryExpr); } |

        expr = simpleUnaryExpression()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse a simple unary expression.
 * 
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                           | TILDE unaryExpression
 *                           | LPAREN basicType RPAREN
 *                               unaryExpression
 *                           | LPAREN
 *                               referenceType
 *                             RPAREN simpleUnaryExpression
 *                           | postfixExpression
 * </pre>
 * 
 * @return an AST for a simpleUnaryExpression.
 */

private JExpression simpleUnaryExpression(): {
    int line = 0;
    Type type = null;
    JExpression expr = null, unaryExpr = null, simpleUnaryExpr = null;
}
{
    try {
        <LNOT> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JLogicalNotOp(line, unaryExpr); } |

        <TILDE> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JTildeOp(line, unaryExpr); } |

        LOOKAHEAD(<LPAREN> basicType() <RPAREN>)
        <LPAREN> { line = token.beginLine; }
        type = basicType()
        <RPAREN>
        unaryExpr = unaryExpression()
        { expr = new JCastOp(line, type, unaryExpr); } |

        LOOKAHEAD(<LPAREN> referenceType() <RPAREN>)
        <LPAREN> { line = token.beginLine; }
        type = referenceType()
        <RPAREN>
        simpleUnaryExpr = simpleUnaryExpression()
        { expr = new JCastOp(line, type, simpleUnaryExpr); } |

        expr = postfixExpression()
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr ; }
}

/**
 * Parse a postfix expression.
 * 
 * <pre>
 *   postfixExpression ::= primary {selector} {INC | DEC}
 * </pre>
 * 
 * @return an AST for a postfixExpression.
 */

private JExpression postfixExpression(): {
    int line = 0; 
    JExpression primaryExpr = null;
}
{
    try {
        primaryExpr = primary() { line = primaryExpr.line(); } 
        (
            primaryExpr = selector(primaryExpr)
        )*
        (
            <DEC>
            { primaryExpr = new JPostDecrementOp(line, primaryExpr); } |

            <INC>
            { primaryExpr = new JPostIncrementOp(line, primaryExpr); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return primaryExpr; }
}

/**
 * Parse a selector.
 * 
 * <pre>
 *   selector ::= DOT qualifiedIdentifier [arguments]
 *              | LBRACK expression RBRACK
 * </pre>
 * 
 * @param target the target expression for this selector.
 *
 * @return an AST for a selector.
 */

private JExpression selector(JExpression target): {
    int line = 0;
    ArrayList<JExpression> args = null;
    TypeName id = null;
    JExpression expr = null;
}
{
    try {
        <DOT> { line = token.beginLine; }
        id = qualifiedIdentifier()
        { expr = new JFieldSelection(line, ambiguousPart(id), target, id.simpleName()); System.out.println("AAAAAAAAAAAAAAAAAAA"); }
        [
            args = arguments()
            { expr = new JMessageExpression(line, target, ambiguousPart(id), id.simpleName(), args); }
        ]

        |

        <LBRACK>
        { line = token.beginLine; expr = new JArrayExpression(line, target, expression()); }
        <RBRACK>
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse a primary expression.
 * 
 * <pre>
 *   primary ::= parExpression
 *             | THIS [arguments]
 *             | SUPER ( arguments 
 *                     | DOT IDENTIFIER [arguments]
 *                     )
 *             | literal
 *             | NEW creator
 *             | qualifiedIdentifier [arguments]
 * </pre>
 * 
 * @return an AST for a primary.
 */

private JExpression primary(): {
    int line = 0;
    JExpression expr = null;
    JExpression newTarget = null;
    ArrayList<JExpression> args = null;
    TypeName id = null;
}
{
    try {
        expr = parExpression() |

        <THIS> { line = token.beginLine; expr = new JThis(line); }
        [
            args = arguments()
            { expr = new JThisConstruction(line, args); }
        ] |
        
        <SUPER> { line = token.beginLine; }
        (
            args = arguments()
            { expr = new JSuperConstruction(line, args); } |
            
            <DOT> <IDENTIFIER>
            {
                newTarget = new JSuper(line);
                expr = new JFieldSelection(line, newTarget,
                                           token.image );
            }
            [
                args = arguments()
                { expr = new JMessageExpression(line, newTarget,
                                                null, token.image, args); }
            ]
        ) |
        expr = literal() |

        <NEW> expr = creator() |

        // Language is ambiguous here. JavaCC warns about not being
        // able to choose between qualifiedIdentifier and selector.
        // Semantic analysis will sort it out.
        id = qualifiedIdentifier()
        {
            line = id.line();
            if (ambiguousPart(id) == null) {
                expr = new JVariable(line, id.simpleName());
            } else {
                expr = new JFieldSelection(line, ambiguousPart(id),
                                            null, id.simpleName());
            }
        }
        [
            args = arguments()
            { expr = new JMessageExpression(line, null,
                                            ambiguousPart(id),
                                            id.simpleName(), args); }
        ]
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse a creator.
 * 
 * <pre>
 *   creator ::= (basicType | qualifiedIdentifier) 
 *                 ( arguments
 *                 | LBRACK RBRACK {LBRACK RBRACK} 
 *                     [arrayInitializer]
 *                 | newArrayDeclarator
 *                 )
 * </pre>
 * 
 * @return an AST for a creator.
 */

private JExpression creator(): {
    int line = 0;
    Type type = null;
    ArrayList<JExpression> args = null;
    ArrayList<JExpression> dims = null;
    JArrayInitializer init =  null;
    JExpression expr = null;
    Type expected = null;
}
{
    try {
        (type = basicType() |
         type = qualifiedIdentifier())
        { line = token.beginLine;
          expected = type; }
        (
            args = arguments()
            { expr = new JNewOp(line, type, args); } |

            LOOKAHEAD(<LBRACK> expression() <RBRACK>)
            expr = newArrayDeclarator(type) |
            <LBRACK> <RBRACK> { expected = new ArrayTypeName(expected); }
            (
                LOOKAHEAD(<LBRACK> <RBRACK>)
                <LBRACK> <RBRACK>
                { expected = new ArrayTypeName(expected); }
            )*
            [
               expr = arrayInitializer(expected)
            ]
        )
    }
    catch (ParseException e) {
        expr = new JWildExpression(token.beginLine);
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parse a new array declarator.
 * 
 * <pre>
 *   newArrayDeclarator ::= LBRACK expression RBRACK 
 *                            {LBRACK expression RBRACK}
 *                            {LBRACK RBRACK}
 * </pre>
 * 
 * @param line line in which the declarator occurred.
 * @param type type of the array.
 *
 * @return an AST for a newArrayDeclarator.
 */

private JNewArrayOp newArrayDeclarator(Type type): {
    int line = 0;
    ArrayList<JExpression> dimensions = new ArrayList<JExpression>();
    JExpression expr = null;
}
{
    try {
        <LBRACK> { line = token.beginLine; } 
        expr = expression() 
        { dimensions.add(expr);
          type = new ArrayTypeName(type); }
        <RBRACK>
        (
            LOOKAHEAD(<LBRACK> expression() <RBRACK>)
            <LBRACK>
            expr = expression()
            { dimensions.add(expr);
              type = new ArrayTypeName(type); }
            <RBRACK>
        )*
        (
            LOOKAHEAD(<LBRACK> <RBRACK>)
            <LBRACK> <RBRACK> { type = new ArrayTypeName(type); }
        )*
    }
    catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JNewArrayOp( line, type, dimensions ); }
}

/**
 * Parse a literal.
 * 
 * <pre>
 *   literal ::= INT_LITERAL | CHAR_LITERAL | STRING_LITERAL | DOUBLE_LITERAL
 *             | TRUE        | FALSE        | NULL
 * </pre>
 * 
 * @return an AST for a literal.
 */

private JExpression literal(): {
    JExpression expr = null;
}
{
    try {
        <INT_LITERAL>
        { expr = new JLiteralInt(token.beginLine, token.image); } |

        <CHAR_LITERAL>
        { expr = new JLiteralChar(token.beginLine, token.image); } |

        <STRING_LITERAL>
        { expr =
              new JLiteralString(token.beginLine, token.image); } |

        <DOUBLE_LITERAL>
        { expr =
              new JLiteralDouble(token.beginLine, token.image); } |

        <TRUE>
        { expr = new JLiteralTrue(token.beginLine); } |

        <FALSE>
        { expr = new JLiteralFalse(token.beginLine); } |

        <NULL>
        { expr = new JLiteralNull(token.beginLine); }
    }
    catch (ParseException e) {
        expr = new JWildExpression(token.beginLine);
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}
